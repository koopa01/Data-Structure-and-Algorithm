# 第一章 数据结构
## 基本概念和术语
    1.数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机事别（可传入计算机中），并输入给计算机处理的符号集合。
        包括整型、实型、字符、声音、图像等非数值型
    2.数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。
        在人类中，人就是数据元素
    3.数据项：一个数据元素可以有若干个数据项组成。
        人这个数据元素中，有眼、耳、鼻等数据项，也可以有年龄、姓名、出生地址等数据项。
        数据项是不可分割的最小单位。（真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点）
    4.数据对象：是性质相同的数据元素的集合，是数据的子集。
        性质相同：指数据元素具有相同数量和类型的数据项，比如：人都有姓名、生日、性别等数据项。
        处理的数据元素通常具有相同性质，为避免混淆，将数据对象都简称为数据。
    5.数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。
        不同数据元素之间不是独立的，而是存在特定的关系，将这些关系称之为结构。

## 逻辑结构与物理结构
    一、逻辑结构：指数据对象中数据元素之间的相互关系。
        1.集合结构：集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。
            即：个数据元素是‘平等’的，他们的共同属性是‘同属于一个集合’。
        2.线性结构：线性结构中的数据元素之前是一对一的关系。
        3.树形结构：树形结构中的数据元素之前存在一种一对多的层次关系。
        4.图形结构：图形结构的数据元素是多对多的关系。
    二、物理结构：指数据的逻辑结构在计算机中的存储形式。
        1.顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。
            就是排队展位，按顺序排好，没人占一小段空间，谁也别插队。（数组）
        2.链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。
            需要用指针存放数据元素的地址，通过地址找到相关联数据元素的位置。
    逻辑结构是面向问题的，物理结构是面向计算机的，其基本目标即是将数据及其逻辑关系存储到计算机中。
## 抽象数据类型
    1.数据类型：指一组性质相同的值的集合及定义在刺激和尚的一些操作的总称。
        数据需要分配内存，内存是有限的，就需要对数据分类，分出多种类型以便控制内存大小。
        原子类型：不可分解的基本类型，比如：整形、实型、字符型等。
        结构类型：有若干个类型组合而成，是可以再分解的，比如：整型数组
    2.抽象数据类型(ADT)：指一个数学模型及定义在该模型上的一组操作。
        抽象：指抽取出事物具有的普遍性的性质。
        抽象的意义在于数据类型的数学抽象特性。
        抽象数据类型的定义仅取决于他的一组逻辑特性，而与其在计算机内部如何表示和实现无关。
            抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。
## 小结
    |                      数据                                      |
    |                     数据对象                                    |
    |     数据元素        |     数据元素         |    数据元素         |
    |数据项1  |  数据项2  |  数据项3  |  数据项4  |  数据项5  |  数据项6|

# 第二章 算法
    算法：是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每个指令表示一个或多个操作。
## 算法的特性
    算法可以帮助更好的理解数据结构
    1.输入输出：零个或多个输入，至少一个或多个输出
    2.有穷性：执行有限的步骤后可以自动结束（每个步骤在可接受的时间内完成）
    3.确定性：算法每一步有确定的含义，不会有二义性
    4.可行性：算法每一步都必须可行（每一步可以通过执行有限次数完成）
## 算法设计要求（标准）
    1.正确性
        1.没有语法错误
        2.对合法的输入数据产生满足要求的输出结果
        * 3.对非法的输入数据产生满足规格说明的结果
        4.对精心选择甚至刁难的测试数据都有满足要求的输出结果
    2.可读性
        便于阅读、理解和交流
    3.健壮性
        当输入数据不合法时，算法能做出相应的处理，而不是异常或是莫名其妙的结果
    4.时间效率高，存储量低
## 算法效率的度量方法
    1.事后统计法
        通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定效率高低
            1.必须事前编写测试程序
            2.依赖硬件软件等环境因素
            3.测试数据的规模设计困难
        综上，缺陷很大，不予考虑。
    2.事前估计法
        在程序编制前，依据统计方法对算法进行估算
        影响效率的因素：
            1.算法采用的策略、方法（根本）
            2.编译产生的代码质量
            3.问题的输入规模（根本）
            4.机器执行指令的速度
## 算法的时间复杂度
    从小到大：
    O(c) < O(logn) < O(n) < O(n*logn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
    推导方法：
        1.没有加法常数不考虑
        2.只保留最高阶项
        3.去除与这项相乘的常数
    所提到的运行时间都是最坏情况下的运行时间
    平均运行时间是期望的结果，最有意义
## 算法的空间复杂度
    算法最好用空间换时间
    空间复杂度 S(n) = O(f(n))
        n为问题规模
        f(n)为语句关于n所占存储空间的函数

# 第三章 线性表(List)
**核心就是“工作指针后移”**
    零个或多个数据元素的有限序列（排好队的组织方式，知道前一个是谁，后一个是谁）
        1.是序列，有顺序，有限的，有头有尾。
        2.当仅有0个元素时，为空表。
        3.在复杂的线性表中，一个数据元素可以由多个数据项组成
        4.数据之间是一对一的关系

## 线性表的顺序存储结构
    1.指的是用一段地址连续的存储单元一次存储线性表的数据元素
        可用一维数组实现顺序存储结构
    2.顺序存储结构需要三个特性：
        1.存储空间的起始位置：数组data的存储位置
        2.线性表的最大存储容量：数组长度Maxsize
        3.线性表的当前长度：length
    3.数组的长度是存放线性表的存储空间的长度，时不变的。
        线性表的长度是线性表中数据元素的个数，随插入、删除而变化。
    4.任意时刻，线性表长度应 < 数组的长度
    5.地址计算方法：存储器中的每个存储单元都有自己的编号，称为地址
        Location(Ai+1) = Location(A) + c
        Location(Ai) = Location(a1) + (i-1)*c
    6.算出线性表中的任意位置的时间都是相同的（任意位置存取数据时间都相同且为常数）
        存储性能 —— 时间复杂度O(1)
        也成为随机存取结构

## 顺序存储结构的插入与删除
    线性表的顺序存储结构，在存、读数据时，不管哪个位置时间复杂度都是O(1)
        在插入、删除时，时间复杂度都是O(n)
    优点：1.无需为表中元素之间的逻辑关系而增加额外存储空间
        2.可以快速的存取表中任意位置的元素
    缺点：1.插入和删除操作需要移动大量元素
        2.当线性表长度变化较大时，难以确定存储空间的容量
        3.造成存储空间的“碎片”

## 线性表的链式存储结构
    既然插入删除时会造成存储空间“碎片”，那就让所有元素不要考虑相邻的位置，哪有空位就到哪里，前一个元素跟后一个元素的内存地址相连
    数据元素信息 + 直接后继元素的存储地址 ——>可以存储在内存未被占用的任意位置
        数据域   +      指针域（存储的指针/链）   ——>两部分信息组成数据的存储映像，称为节点(Node)
    链表的每个节点中只包含一个指针域，叫做单链表
        链表第一个节点的存储位置叫头指针，最后一个节点的指针为“空”（Null 或 “ ^ ”）
        单链表的第一个节点前附设一个节点，叫头节点，可以不存储任何信息，也可以存储线性表长度等附加信息，指针域存储指向第一个节点的指针

## 单链表的读取
    对单链表实现获取第i个元素的数据的操作GetElem：
        1.声明一个节点p指向链表第一个节点，初始化j从1开始
        2.当j < i时，遍历链表，让p的指针向后移动，不断指向下一个节点，j累加1
        3.若链表末尾p为空，则说明第i个元素不存在
        4.否则查找成功，返回节点p的数据
            就是从头开始找，直到第i个元素位置。当i = n时，遍历n - 1次，因此最坏情况时间复杂度O(n)

## 单链表的插入与删除
    1.插入
        ——> a1 | a1 ——> a2 | a2 ——>
               p       p ——> next
        让 e | e = s 插入a1和a2
        只需改变s ——> next = p ——> next,之后 p ——> next = s
        即，让p的后继节点改成s的后继节点，再把节点s变成p的后继节点
            如果先 p ——> next = s, 再s ——> next = p ——> next则会造成先覆盖了s的地址，后一步为s指向s的存储地址。
    2.删除
        设a2的节点为q，要实现将节点q删除单链表
            就是将它的前继节点的指针绕过，指向它的后继节点即可。
        ——> a1 | a1 ——> a2 | a2 ——> a3 | a3  ——>
               p     q/p ——> next   q ——> next
        只需p ——> next = p ——> next ——> next，或者 q = p ——> next; p ——> next = q ——> next
    3.总结
        插入和删除都是由两部分组成：
            1.遍历查找第i个元素
            2.插入或删除元素
        时间复杂度都是O(n)，即不管一次插入多少元素，删除多少元素，只需遍历一次。这就是单链表的效率优势。

## 单链表的整表创建
    其实就是一个数组的初始化，但电表可以很散，不像顺序存储结构这么集中，是动态结构，所占空间大小和位置不需预先分配划定。
        创建的算法（就是插入操作）：
            1.声明一节点p和计数器变量i
            2.初始化一空链表L
            3.让L的头节点的指针指向NULL，即建立一个带头结点的单链表
            4.循环：
                + 生成一新结点赋值给p
                + 随机生成艺术字赋值给p的数据域 p ——> data
                + 将p插入到头节点与前一新节点之间
                + 最后 pn ——> next = NULL
        实际应用可以采用尾插法，即每次把新结点插入到终端节点的后面。

## 单链表的整表删除
    注意：一定要声明前后两个变量p、q，因为p既有数据域，还有指针域，始放p实际是对他整个节点进行删除和内存释放，需要等当前节点释放后，把下一节点拿回来补充，否则会报错。
        1.声明一节点p和q
        2.将第一个节点赋值给p
        3.循环：
            + 将下一节点赋值给q
            + 释放p
            + 将q赋值给p

## 单链表 和 顺序存储 的结构优缺点
    存储分配方式：
        1.顺序存储用连续的存储单元，连续存储
        2.单链表用任意存储单元，实现链式存储
    时间性能：
        查找：
            1.顺序存储 O(1)
            2.单链表 O(n)
        插入和删除：
            1.顺序存储需平均一共表长一半的元素，O(n)
            2.单链表只需更改某一或两个指针，O(1)
    空间性能：
        1.顺序存储需预分配存储空间，分大浪费，分小溢出
        2.单链表任意分配存储空间，元素个数不受限制
    结论:
        1.需频繁查找用顺序存储，比如用户注册的个人信息，插入一次之后都是读取
        2.需频繁插入删除用单链表，比如游戏装备列表，随时增加删除
        3.当元素个数变化较大或未知多大时，用线性表
        4.当事先知道大致长度，用顺序存储，比如时间（只有12个月，一周七天）

## 静态链表
    不用指针，用数组代替指针实现的单链表，即用数组表述的链表叫做静态链表
    用游标实现法：
        1.用data数据域和cur数据域表示
        2.先对数组第一个和最后一个元素做特殊元素处理，不存数据
        3.首元素的data不存数据，cur存备用链表（闲置的节点）的第一个节点下标
        4.最后一个元素的data不存数据，cur用来存放第一个插入元素的小标，相当于头节点
## 循环链表
    将单链表中终端节点的之诊断有空指针改为指向头节点，使整个单链表形成一个环，即头尾相接。
    可从一个结点出发，访问到整个链表的所有节点
        1.和单链表相似，只是最后的节点指向头节点
        2.改变循环的判断条件，原来是判断 p ——> next, 现在是 p ——> next 不等于头节点，则循环未结束。
    这样先有头节点，需要循环整个链表才能找到终端节点
        如果不用头指针，用尾指针则可最快找到头节点和终端节点
    合并的时候，假设两个尾指针的循环链表，只需终端节点A指向终端节点B的下一个元素，终端节点B指向终端节点A的下一个元素

## 双向链表
    单链表中，查找下一个元素用next指针，时间复杂度O(1),查找上一个节点最坏就是O(n)
        双向链表实在单链表的每个节点中都有两个指针域，一个指向直接后续，另一个指向直接前驱。即用空间换时间
    双向链表可以反向遍历查找，但是插入和删除需要更改两个指针变量
    插入操作需：
        先把目标节点的两个指针分别给前节点的后指针和后节点的前指针
        再把前节点的后指针和厚街店的前指针指向目标节点
    删除操作同理
## 总结
                    线性表
    顺序存储结构 | 链式存储结构
                | 单链表 | 静态链表 | 循环链表 | 双向链表

# 第四章 栈与队列
    栈使限定在表尾进行插入和删除操作的线性表
    队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表
## 