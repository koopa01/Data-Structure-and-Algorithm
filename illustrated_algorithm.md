# 第1章 算法简介
## 1.二分查找
    一般而言，对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。
## 2.大O表示法 
    1.指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速。
    算法的速度指的并非时间，而是操作数的增速。

    2.
    O(log n)，也叫对数时间，这样的算法包括二分查找。
    O(n)，也叫线性时间，这样的算法包括简单查找。
    O(n ＊ log n)，快速排序——一种速度较快的排序算法。
    O(n2)，选择排序——一种速度较慢的排序算法。
    O(n! )，旅行商问题的解决方案——一种非常慢的算法。

    3.计算机科学领域非常著名的旅行商问题，其计算时间增加得非常快:
    这位旅行商要前往这5个城市，同时要确保旅程最短。为此，可考虑前往这些城市的各种可能顺序。
    对于每种顺序，他都计算总旅程，再挑选出旅程最短的路线。5个城市有120种不同的排列方式。
    因此，在涉及5个城市时，解决这个问题需要执行120次操作。
    涉及6个城市时，需要执行720次操作（有720种不同的排列方式）。
    涉及7个城市时，需要执行5040次操作！

# 第2章 选择排序
    1.两种最基本的数据结构——数组和链表
    2.还记得二分查找吗？它只能用于有序元素列表。本章将介绍选择排序。
    3.需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。但它们并非都适用于所有的情形，因此知道它们的差别很重要。接下来介绍数组和链表以及它们的优缺点。
## 数组和链表
    1.使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。
    2.在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是“预留座位”：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。
    3.它存在如下两个缺点:
        你额外请求的位置可能根本用不上，这将浪费内存。你没有使用，别人也用不了。
        待办事项超过10个后，你还得转移。
    因此，这种权宜措施虽然不错，但绝非完美的解决方案。对于这种问题，可使用链表来解决。
## 链表
    1.链表中的元素可存储在内存的任何地方。
    2.链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。
        在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。
        链表的优势在插入元素方面
## 数组
    1.需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。
    但如果你需要跳跃，链表的效率真的很低。
    2.数组与此不同：你知道其中每个元素的地址。
        需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。
             | 数组 | 链表
        读取 | O(1) | O(n)
        插入 | O(n) | o(1)
## 在中间插入与删除
    1.需要在中间插入元素时，数组和链表哪个更好呢？
        使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。
        而使用数组时，则必须将后面的元素都向后移。
        如果没有足够的空间，可能还得将整个数组复制到其他地方！因此，当需要**在中间插入元素**时，**链表**是更好的选择。
    2.如果你要删除元素呢？
        **链表**也是更好的选择，因为只需修改前一个元素指向的地址即可。
        而使用数组时，删除元素后，必须将后面的元素都向前移。
             | 数组 | 链表
        读取 | O(1) | O(n)
        插入 | O(n) | O(1)
        删除 | O(n) | O(1)
    3.需要指出的是，仅当能够立即访问要删除的元素时，删除操作的运行时间才为O(1)。
    通常我们都记录了链表的第一个元素和最后一个元素，因此删除这些元素时运行时间为O(1)。
## 比较
    1.数组用得很多，因为它支持随机访问。
        链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。
        随机访问意味着可直接跳到第十个元素。
    2.数组的元素都在一起。
    3.链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
    4.数组的读取速度很快。
    5。链表的插入和删除速度很快。
## 选择排序
    选择排序是一种灵巧的算法，但其速度不是很快。

# 第3章 递归
    递归只是让解决方案更清晰，并没有性能上的优势。
    Leigh Caldwell在Stack Overflow上说的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”
## 基线条件和递归条件
    1.每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。
        递归条件指的是函数何时调用自己
        基线条件则指的是函数何时不再调用自己，从而避免形成无限循环。
    2.所有函数调用都进入调用栈。
    3.调用栈可能很长，这将占用大量的内存。
