# 第1章 算法简介
## 1.二分查找
    一般而言，对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。
## 2.大O表示法 
    1.指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速。
    算法的速度指的并非时间，而是操作数的增速。

    2.
    O(log n)，也叫对数时间，这样的算法包括二分查找。
    O(n)，也叫线性时间，这样的算法包括简单查找。
    O(n ＊ log n)，快速排序——一种速度较快的排序算法。
    O(n2)，选择排序——一种速度较慢的排序算法。
    O(n! )，旅行商问题的解决方案——一种非常慢的算法。

    3.计算机科学领域非常著名的旅行商问题，其计算时间增加得非常快:
    这位旅行商要前往这5个城市，同时要确保旅程最短。为此，可考虑前往这些城市的各种可能顺序。
    对于每种顺序，他都计算总旅程，再挑选出旅程最短的路线。5个城市有120种不同的排列方式。
    因此，在涉及5个城市时，解决这个问题需要执行120次操作。
    涉及6个城市时，需要执行720次操作（有720种不同的排列方式）。
    涉及7个城市时，需要执行5040次操作！

# 第2章 选择排序
    1.两种最基本的数据结构——数组和链表
    2.还记得二分查找吗？它只能用于有序元素列表。本章将介绍选择排序。
    3.需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。但它们并非都适用于所有的情形，因此知道它们的差别很重要。接下来介绍数组和链表以及它们的优缺点。
## 数组和链表
    1.使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。
    2.在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是“预留座位”：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。
    3.它存在如下两个缺点:
        你额外请求的位置可能根本用不上，这将浪费内存。你没有使用，别人也用不了。
        待办事项超过10个后，你还得转移。
    因此，这种权宜措施虽然不错，但绝非完美的解决方案。对于这种问题，可使用链表来解决。
## 链表
    1.链表中的元素可存储在内存的任何地方。
    2.链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。
        在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。
        链表的优势在插入元素方面
## 数组
    1.需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。
    但如果你需要跳跃，链表的效率真的很低。
    2.数组与此不同：你知道其中每个元素的地址。
        需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。
             | 数组 | 链表
        读取 | O(1) | O(n)
        插入 | O(n) | o(1)
## 在中间插入与删除
    1.需要在中间插入元素时，数组和链表哪个更好呢？
        使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。
        而使用数组时，则必须将后面的元素都向后移。
        如果没有足够的空间，可能还得将整个数组复制到其他地方！因此，当需要**在中间插入元素**时，**链表**是更好的选择。
    2.如果你要删除元素呢？
        **链表**也是更好的选择，因为只需修改前一个元素指向的地址即可。
        而使用数组时，删除元素后，必须将后面的元素都向前移。
             | 数组 | 链表
        读取 | O(1) | O(n)
        插入 | O(n) | O(1)
        删除 | O(n) | O(1)
    3.需要指出的是，仅当能够立即访问要删除的元素时，删除操作的运行时间才为O(1)。
    通常我们都记录了链表的第一个元素和最后一个元素，因此删除这些元素时运行时间为O(1)。
## 比较
    1.数组用得很多，因为它支持随机访问。
        链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。
        随机访问意味着可直接跳到第十个元素。
    2.数组的元素都在一起。
    3.链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
    4.数组的读取速度很快。
    5。链表的插入和删除速度很快。
## 选择排序
    选择排序是一种灵巧的算法，但其速度不是很快。

# 第3章 递归
    递归只是让解决方案更清晰，并没有性能上的优势。
    Leigh Caldwell在Stack Overflow上说的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”
## 基线条件和递归条件
    1.每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。
        递归条件指的是函数何时调用自己
        基线条件则指的是函数何时不再调用自己，从而避免形成无限循环。
    2.所有函数调用都进入调用栈。
    3.调用栈可能很长，这将占用大量的内存。

# 第4章 快速排序
    学习分而治之（divide and conquer, D&C）。有时候可能会遇到使用任何已知的算法都无法解决的问题。
        优秀的算法学家遇到这种问题时，不会就此放弃，而是尝试使用掌握的各种问题解决方法来找出解决方案。分而治之是第一种通用的问题解决方法。
    学习快速排序——一种常用的优雅的排序算法。快速排序使用分而治之的策略。
## 分而治之
    如何将一块地均匀地分成方块，并确保分出的方块是最大的呢？
        (1) 找出基线条件，这种条件必须尽可能简单。
        (2) 不断将问题分解（或者说缩小规模），直到符合基线条件。
    首先，找出基线条件。
        可以将这块地分成两个短边长的正方块。现在需要找出递归条件，这正是D&C的用武之地。根据D&C的定义，每次递归调用都必须缩小问题的规模。
        余下一小块地。现在是顿悟时刻：何不对余下的那一小块地使用相同的算法呢？
        直到找出最小的无余数的方块，则为最后的解。
            例：给定一个数字数组。将这些数字相加，并返回结果。
                ```
                def sum_number(num):
                    if len(num) > 1:    #基线条件：数组中只有一个元素时停止
                        s = num.pop(0) + sum_number(num)    #将问题分解为第一个数加剩下的所有数
                        return s
                    else:
                        s = num.pop(0)
                        return s
                print('sum = ', sum_number([1,2,3,4,5]))
                ```
            编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样的。
## 快速排序
    1.标准库中的函数qsort实现的就是快速排序。快速排序也使用了D&C。
    2.首先，从数组中选择一个元素，这个元素被称为基准值  （pivot）。[33,1,7,15,10]
      接下来，找出比基准值小的元素以及比基准值大的元素。[1,7,15,10]+[33]+[]
      这里只是进行了分区，得到的两个子数组是无序的。如果子数组是有序的，就可以合并得到一个有序的数组：左边的数组+基准值+右边的数组。
      只要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组！ quicksort([1,7,15,10])+[33]+quicksort([])
        (1) 选择基准值。
        (2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。
        (3) 对这两个子数组进行快速排序。
    这种思想也叫归纳证明
    ```
    def quicksort(array):
        if len(array) < 2:
            return array    # 基线条件：为空或只有一个元素的数组是有序的
        else:
            pivot = array[0]
            less = [i for i in array[1:] if i <= pivot]    # 小于等于基准值的子数组
            greater = [i for i in array[1:] if i > pivot]    # 大于基准值的子数组
            return quicksort(less) + [pivot] + quicksort(greater)
    print(quicksort([1,7,33,15,10]))
    ```
## 比较合并排序和快速排序
    1.还有一种名为合并排序（merge sort）的排序算法，其运行时间为O(n log n)，比选择排序快得多！快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。
    与选择排序一样慢！但这是最糟情况。在平均情况下，快速排序的运行时间为O(n log n)。
    2.有时候，常量的影响可能很大，对快速查找和合并查找来说就是如此。
    快速查找的常量比合并查找小，因此如果它们的运行时间都为O(n log n)，快速查找的速度将更快。
    3.实际上，快速查找的速度确实更快，因为相对于遇上最糟情况，它遇上平均情况的可能性要大得多。
        层数为O(log n)（用技术术语说，调用栈的高度为O(log n)），而每层需要的时间为O(n)。因此整个算法需要的时间为O(n) ＊ O(log n)=O(n log n)。这就是最佳情况。
        在最糟情况下，有O(n)层，因此该算法的运行时间为O(n) ＊ O(n)=O(n2)。
    4.只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为O(n log n)。快速排序是最快的排序算法之一，也是D&C典范。