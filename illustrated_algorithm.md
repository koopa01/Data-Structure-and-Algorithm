# 第1章 算法简介
## 1.二分查找
    一般而言，对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。
## 2.大O表示法 
    1.指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速。
    算法的速度指的并非时间，而是操作数的增速。

    2.
    O(log n)，也叫对数时间，这样的算法包括二分查找。
    O(n)，也叫线性时间，这样的算法包括简单查找。
    O(n ＊ log n)，快速排序——一种速度较快的排序算法。
    O(n2)，选择排序——一种速度较慢的排序算法。
    O(n! )，旅行商问题的解决方案——一种非常慢的算法。

    3.计算机科学领域非常著名的旅行商问题，其计算时间增加得非常快:
    这位旅行商要前往这5个城市，同时要确保旅程最短。为此，可考虑前往这些城市的各种可能顺序。
    对于每种顺序，他都计算总旅程，再挑选出旅程最短的路线。5个城市有120种不同的排列方式。
    因此，在涉及5个城市时，解决这个问题需要执行120次操作。
    涉及6个城市时，需要执行720次操作（有720种不同的排列方式）。
    涉及7个城市时，需要执行5040次操作！

# 第2章 选择排序
    1.两种最基本的数据结构——数组和链表
    2.还记得二分查找吗？它只能用于有序元素列表。本章将介绍选择排序。
    3.需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。但它们并非都适用于所有的情形，因此知道它们的差别很重要。接下来介绍数组和链表以及它们的优缺点。
## 数组和链表
    1.使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。
    2.在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是“预留座位”：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。
    3.它存在如下两个缺点:
        你额外请求的位置可能根本用不上，这将浪费内存。你没有使用，别人也用不了。
        待办事项超过10个后，你还得转移。
    因此，这种权宜措施虽然不错，但绝非完美的解决方案。对于这种问题，可使用链表来解决。
## 链表
    1.链表中的元素可存储在内存的任何地方。
    2.链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。
        在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。
        链表的优势在插入元素方面
## 数组
    1.需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。
    但如果你需要跳跃，链表的效率真的很低。
    2.数组与此不同：你知道其中每个元素的地址。
        需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。
             | 数组 | 链表
        读取 | O(1) | O(n)
        插入 | O(n) | o(1)
## 在中间插入与删除
    1.需要在中间插入元素时，数组和链表哪个更好呢？
        使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。
        而使用数组时，则必须将后面的元素都向后移。
        如果没有足够的空间，可能还得将整个数组复制到其他地方！因此，当需要**在中间插入元素**时，**链表**是更好的选择。
    2.如果你要删除元素呢？
        **链表**也是更好的选择，因为只需修改前一个元素指向的地址即可。
        而使用数组时，删除元素后，必须将后面的元素都向前移。
             | 数组 | 链表
        读取 | O(1) | O(n)
        插入 | O(n) | O(1)
        删除 | O(n) | O(1)
    3.需要指出的是，仅当能够立即访问要删除的元素时，删除操作的运行时间才为O(1)。
    通常我们都记录了链表的第一个元素和最后一个元素，因此删除这些元素时运行时间为O(1)。
## 比较
    1.数组用得很多，因为它支持随机访问。
        链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。
        随机访问意味着可直接跳到第十个元素。
    2.数组的元素都在一起。
    3.链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
    4.数组的读取速度很快。
    5。链表的插入和删除速度很快。
## 选择排序
    选择排序是一种灵巧的算法，但其速度不是很快。

# 第3章 递归
    递归只是让解决方案更清晰，并没有性能上的优势。
    Leigh Caldwell在Stack Overflow上说的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”
## 基线条件和递归条件
    1.每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。
        递归条件指的是函数何时调用自己
        基线条件则指的是函数何时不再调用自己，从而避免形成无限循环。
    2.所有函数调用都进入调用栈。
    3.调用栈可能很长，这将占用大量的内存。

# 第4章 快速排序
    学习分而治之（divide and conquer, D&C）。有时候可能会遇到使用任何已知的算法都无法解决的问题。
        优秀的算法学家遇到这种问题时，不会就此放弃，而是尝试使用掌握的各种问题解决方法来找出解决方案。分而治之是第一种通用的问题解决方法。
    学习快速排序——一种常用的优雅的排序算法。快速排序使用分而治之的策略。
## 分而治之
    如何将一块地均匀地分成方块，并确保分出的方块是最大的呢？
        (1) 找出基线条件，这种条件必须尽可能简单。
        (2) 不断将问题分解（或者说缩小规模），直到符合基线条件。
    首先，找出基线条件。
        可以将这块地分成两个短边长的正方块。现在需要找出递归条件，这正是D&C的用武之地。根据D&C的定义，每次递归调用都必须缩小问题的规模。
        余下一小块地。现在是顿悟时刻：何不对余下的那一小块地使用相同的算法呢？
        直到找出最小的无余数的方块，则为最后的解。
            例：给定一个数字数组。将这些数字相加，并返回结果。
                ```
                def sum_number(num):
                    if len(num) > 1:    #基线条件：数组中只有一个元素时停止
                        s = num.pop(0) + sum_number(num)    #将问题分解为第一个数加剩下的所有数
                        return s
                    else:
                        s = num.pop(0)
                        return s
                print('sum = ', sum_number([1,2,3,4,5]))
                ```
            编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样的。
## 快速排序
    1.标准库中的函数qsort实现的就是快速排序。快速排序也使用了D&C。
    2.首先，从数组中选择一个元素，这个元素被称为基准值  （pivot）。[33,1,7,15,10]
      接下来，找出比基准值小的元素以及比基准值大的元素。[1,7,15,10]+[33]+[]
      这里只是进行了分区，得到的两个子数组是无序的。如果子数组是有序的，就可以合并得到一个有序的数组：左边的数组+基准值+右边的数组。
      只要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组！ quicksort([1,7,15,10])+[33]+quicksort([])
        (1) 选择基准值。
        (2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。
        (3) 对这两个子数组进行快速排序。
    这种思想也叫归纳证明
    ```
    def quicksort(array):
        if len(array) < 2:
            return array    # 基线条件：为空或只有一个元素的数组是有序的
        else:
            pivot = array[0]
            less = [i for i in array[1:] if i <= pivot]    # 小于等于基准值的子数组
            greater = [i for i in array[1:] if i > pivot]    # 大于基准值的子数组
            return quicksort(less) + [pivot] + quicksort(greater)
    print(quicksort([1,7,33,15,10]))
    ```
## 比较合并排序和快速排序
    1.还有一种名为合并排序（merge sort）的排序算法，其运行时间为O(n log n)，比选择排序快得多！快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。
    与选择排序一样慢！但这是最糟情况。在平均情况下，快速排序的运行时间为O(n log n)。
    2.有时候，常量的影响可能很大，对快速查找和合并查找来说就是如此。
    快速查找的常量比合并查找小，因此如果它们的运行时间都为O(n log n)，快速查找的速度将更快。
    3.实际上，快速查找的速度确实更快，因为相对于遇上最糟情况，它遇上平均情况的可能性要大得多。
        层数为O(log n)（用技术术语说，调用栈的高度为O(log n)），而每层需要的时间为O(n)。因此整个算法需要的时间为O(n) ＊ O(log n)=O(n log n)。这就是最佳情况。
        在最糟情况下，有O(n)层，因此该算法的运行时间为O(n) ＊ O(n)=O(n2)。
    4.只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为O(n log n)。快速排序是最快的排序算法之一，也是D&C典范。

# 第5章 散列表(hash table)
    散列表的内部机制：实现、冲突和散列函数。
    假设你在一家杂货店上班。有顾客来买东西时，你得在一个本子中查找价格。
        如果本子的内容不是按字母顺序排列的，你可能为查找苹果（apple）的价格而浏览每一行，这需要很长的时间。
        此时你使用的是第1章介绍的简单查找，需要浏览每一行。这需要时间O(n)。
        如果本子的内容是按字母顺序排列的，可使用二分查找来找出苹果的价格，这需要的时间更短，为O(log n)。
        若有一名能够记住所有商品价格的雇员，这样你就不用查找了，报出任何商品的价格的时间都为O(1)。
    散列表适合用于：
        1.模拟映射关系；
        2.防止重复； #冲突
        3.缓存/记住数据，以免服务器再通过处理来生成它们。

## 散列函数
    散列函数“将输入映射到数字”。是无论你给它什么数据，它都还你一个数字。
    散列函数准确地指出了价格的存储位置，你根本不用查找！
    散列函数总是将同样的输入映射到相同的索引。
        1.每次你输入avocado，得到的都是同一个数字。因此，可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来确定鳄梨的价格存储在什么地方。
        2.散列函数将不同的输入映射到不同的索引。avocado映射到索引4, milk映射到索引0。每种商品都映射到数组的不同位置，让你能够将其价格存储到这里。
        3.散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。
    于是，结合使用散列函数和数组创建了一种被称为散列表（hash table）的数据结构。
        Python提供的散列表实现为字典。
    ```
    book['apple'] = 0.67
    book['milk'] = 1.49
    book['avocado'] =  1.49
    print(book)
    #{'avocado': 1.49, 'apple': 0.67, 'milk': 1.49}
    ```
        散列表由键和值组成。在前面的散列表book中，键为商品名，值为商品价格。散列表将键映射到值。
## 将散列表用于查找
    假设要创建一个类似手机的电话簿，将姓名映射到电话号码。该电话簿需要提供如下功能。
        1.添加联系人及其电话号码。
        2.通过输入联系人来获悉其电话号码。
    这非常适合使用散列表来实现！在下述情况下，使用散列表是很不错的选择。
        1.创建映射。
        2.查找。
    ```
    phone_book = {}
    phone_book['jenny'] = 8675309
    phone_book['emergency'] = 911

    print(phone_book['jenny'])
    # 8675309
    ```
        DNS解析（DNSresolution），散列表是提供这种功能的方式之一。
## 防止重复
    假设你负责管理一个投票站。显然，每人只能投一票，但如何避免重复投票呢？有人来投票时，你询问他的全名，并将其与已投票者名单进行比对。
    ```
    voted = {}
    def check_voter(name):
        if voted.get(name):
            print('kick him out')
        else:
            voted[name] = true
            print('let them vote')
    ```
    使用散列表来检查是否重复，速度非常快。
## 将散列表用作缓存
    当你访问Facebook的页面时，它首先检查散列表中是否存储了该页面。
    ```
    cache = {}
    def get_page(url):
        if cache.get(url):
            return cache[url]   #返回缓存的数据
        else:
            data = get_data_from_server(url)
            cache[url] = data   #先将数据保存到缓存中
            return data
    ```
## 冲突
    若水果店存储数据，建立数组存储单词A-Z开头的水果，按字母表顺序分配数组的位置。
        若已经存了apple，还想再存avocado，则造成冲突。
        所以，如果两个键映射到了同一个位置，就在这个位置存储一个链表。
    散列函数很重要。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。
    如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，这些链表就不会很长！
## 性能
    在平均情况下，散列表执行各种操作的时间都为O(1)。
    在最糟情况下，散列表所有操作的运行时间都为O(n)。
    在使用散列表时，避开最糟情况至关重要，需要避免冲突。需要有：
        1.较低的填装因子；  #装填因子为数组中被占用（已存储）的位置数/总位置数，最好为0.7。
            填装因子大于1意味着装因子过大，需要在散列表中添加位置，这被称为调整长度（resizing）。
                为此，你首先创建一个更长的新数组：通常将数组增长一倍。
                接下来，需要使用函数hash将所有的元素都插入到这个新的散列表中。
            填装因子越低，发生冲突的可能性越小，散列表的性能越高。
        2.良好的散列函数。
            良好的散列函数让数组中的值呈均匀分布。
            糟糕的散列函数让值扎堆，导致大量的冲突。
            SHA函数
## 总结
    散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型。你可能很快会发现自己经常在使用它。
        1.你可以结合散列函数和数组来创建散列表。
        2.冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。
        3.散列表的查找、插入和删除速度都非常快。
        4.散列表适合用于模拟映射关系。
        5.一旦填装因子超过0.7，就该调整散列表的长度。
        6.散列表可用于缓存数据（例如，在Web服务器上）。
        7.散列表非常适合用于防止重复。

# 第6章 广度优先搜索
    假设你居住在旧金山，要从双子峰前往金门大桥。你想乘公交车前往，并希望换乘最少。
        金门大桥未突出，因此一步无法到达那里。两步能吗？金门大桥也未突出，因此两步也到不了。三步呢？
        还有其他前往金门大桥的路线，但它们更远（需要四步）。
    这个算法发现，前往金门大桥的最短路径需要三步。这种问题被称为最短路径问题（shorterst-path problem）。
        你经常要找出最短路径，这可能是前往朋友家的最短路径，也可能是国际象棋中把对方将死的最少步数。解决最短路径问题的算法被称为广度优先搜索。
## 图是什么
    1.图由节点（node）和边（edge）组成。
    2.一个节点可能与众多节点直接相连，这些节点被称为邻居。
    3.根据关系远近，例如，朋友是一度关系，朋友的朋友是二度关系。
    图用于模拟不同的东西是如何相连的。
## 广度优先搜索
    第一类问题：从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？）
    第二类问题：从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？）
        一度关系胜过二度关系，二度关系胜过三度关系，以此类推。因此，你应先在一度关系中搜索，确定其中没有芒果销售商后，才在二度关系中搜索。
    1.你按顺序依次检查名单中的每个人，看看他是否是芒果销售商。
    2.这将先在一度关系中查找，再在二度关系中查找，因此找到的是关系最近的芒果销售商。
    3.广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径。
        # 需要按添加顺序查找，才能实现这样的目的 —— 队列
## 队列
    队列是一种先进先出（First In First Out, FIFO）的数据结构，而栈是一种后进先出（Last InFirst Out, LIFO）的数据结构。
    入队、出队 = 压入、弹出
## 实现图
    图由多个节点组成。每个节点都与邻近节点相连，如果表示类似于“你→Bob”这样的关系呢？
    好在你知道的一种结构让你能够表示这种关系，它就是散列表！
    记住，散列表让你能够将键映射到值。在这里，你要将节点映射到其所有邻居。
    ```
    graph = {}
    graph['you'] = ['alice','bob','claire']
    graph['bob'] = ['anuj','peggy']
    graph['alice'] = ['peggy']
    graph['claire'] = ['thom','jonny']
    graph['anuj'] = []
    graph['peggy'] = []
    graph['thom'] = []
    graph['jonny'] = []
    ```
    # 'you'被映射到了一个数组，因此graph["you"]是一个数组，其中包含了“你”的所有邻居。
    # 散列表是无序的，因此添加键—值对的顺序无关紧要。
    Anuj、Peggy、Thom和Jonny都没有邻居，这是因为虽然有指向他们的箭头，但没有从他们出发指向其他人的箭头。
        这被称为有向图（directed graph），其中的关系是单向的。因此，Anuj是Bob的邻居，但Bob不是Anuj的邻居。
        无向图（undirected graph）没有箭头，直接相连的节点互为邻居。
## 实现算法
    1.创建一个队列，用于储存要检查的人
    2.从队列中弹出一个人
    3.检查这个人是否是芒果销售商
    4.判定：a.是，大功告成
            b.否，将这个人的所有邻居加入队列
    5.回到第2步
    6.如果队列为空，说明人际关系网中没有芒果销售商
    ```
    from collections import deque

    search_queue = deque()  #创建一个双端队列
    search_queue += graph['you']    #graph["you"]是一个数组，其中包含你的所有邻居，如["alice", "bob","claire"]。

    while search_queue:     #只要队列不为空
        person = search_queue.popleft()     #就去出其中的第一个人
        if person_is_seller(person):    #检查是否是芒果销售商
            print(person + 'is a mango seller!')
            return True
        else:
            search_queue += graph[person]   #不是芒果销售商，将这个人的朋友都加入搜索队列
    return False    #如果到达这里，说明队列中没认识芒果销售商

    def person_is_seller(name):
        return name[-1] == 'm'  #这个函数检查人的姓名是否以m结尾：如果是，他就是芒果销售商。(只是举例)
    ```
    这个算法将不断执行，直到满足以下条件之一：
        1.找到一位芒果销售商；
        2.队列变成空的，这意味着你的人际关系网中没有芒果销售商。
    有一个问题：Peggy既是Alice的朋友又是Bob的朋友，因此她将被加入队列两次：一次是在添加Alice的朋友时，另一次是在添加Bob的朋友时。
        因此，检查完一个人后，应将其标记为已检查，且不再检查他。
        如果不这样做，就可能会导致无限循环。
    ```
    from collections import deque

    def search(name):
        search_queue = deque()
        search_queue += graph[name]
        searched = []    # 这数组用于记录已经被检查过的人

        while search_queue:
            person = search_queue.popleft()
            if person not in searched:  #仅当这个人没被检查过时才检查
                if person_is_seller(person):
                    print(person + 'is a mango seller!')
                    return True
                else:
                    search_queue += graph[person] 
                    search.append(person)   #标记这个人被检查过
        return False    

    def person_is_seller(name):
        return name[-1] == 'm'
    ```
### 运行时间
    如果你在你的整个人际关系网中搜索芒果销售商，就意味着你将沿每条边前行（记住，边是从一个人到另一个人的箭头或连接），因此运行时间至少为O（边数）。
    你还使用了一个队列，其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的，即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。
        所以，广度优先搜索的运行时间为O(人数+边数)，这通常写作O(V+E)，其中V为顶点（vertice）数，E为边数。
### 拓扑排序
    如果任务A依赖于任务B，在列表中任务A就必须在任务B后面。从某种程度上说，这种列表是有序的。
    这被称为拓扑排序，使用它可根据图创建一个有序列表。
        例如：你正在规划一场婚礼，并有一个很大的图，其中充斥着需要做的事情，但却不知道要从哪里开始。这时就可使用拓扑排序来创建一个有序的任务列表。
        例如：家谱。这种图被称为树。树是一种特殊的图，其中没有往后指的边。
## 小结
    1.广度优先搜索指出是否有从A到B的路径。
    2.如果有，广度优先搜索将找出最短路径。
    3.面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题。
    4.有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama→adit表示rama欠adit钱。
    5.无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约会，而rachel也与ross约会”。
    6.队列是先进先出（FIFO）的。❑ 栈是后进先出（LIFO）的。
    7.你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。
    8.对于检查过的人，务必不要再去检查，否则可能导致无限循环。